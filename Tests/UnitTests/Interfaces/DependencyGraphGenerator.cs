using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using NUnit.Framework;

namespace DOL.Tests.Unit.Interfaces
{
    /// <summary>
    /// FIEX-015: Create interface dependency graphs
    /// Generates visual dependency graphs and analysis reports
    /// </summary>
    [TestFixture]
    public class DependencyGraphGenerator
    {
        private Assembly _gameServerAssembly;
        private Type[] _allInterfaces;

        [SetUp]
        public void Setup()
        {
            _gameServerAssembly = typeof(DOL.GS.GameServer).Assembly;
            _allInterfaces = _gameServerAssembly.GetTypes()
                .Where(t => t.IsInterface && 
                           (t.Namespace?.Contains("Interfaces") == true || t.Name.StartsWith("I")))
                .ToArray();
        }

        [Test]
        [Category("Documentation")]
        public void GenerateInterfaceDependencyGraphs()
        {
            var outputDir = TestContext.CurrentContext.WorkDirectory ?? "./";
            
            // Generate Mermaid graph for markdown documentation
            var mermaidGraph = CreateMermaidGraph();
            var mermaidPath = Path.Combine(outputDir, "interface_dependencies.mermaid");
            File.WriteAllText(mermaidPath, mermaidGraph);
            
            // Generate analysis report
            var report = CreateAnalysisReport();
            var reportPath = Path.Combine(outputDir, "interface_analysis.md");
            File.WriteAllText(reportPath, report);

            TestContext.WriteLine($"📊 Generated dependency analysis:");
            TestContext.WriteLine($"  Mermaid Graph: {mermaidPath}");
            TestContext.WriteLine($"  Analysis Report: {reportPath}");
            TestContext.WriteLine($"📈 Analyzed {_allInterfaces.Length} interfaces");

            // Validate outputs
            Assert.That(File.Exists(mermaidPath), Is.True, "Mermaid graph should be generated");
            Assert.That(File.Exists(reportPath), Is.True, "Analysis report should be generated");
            Assert.That(mermaidGraph, Contains.Substring("graph TD"), "Mermaid should be valid");
            Assert.That(report, Contains.Substring("# Interface"), "Report should be valid markdown");
        }

        private string CreateMermaidGraph()
        {
            var sb = new StringBuilder();
            sb.AppendLine("graph TD");
            sb.AppendLine("  %% OpenDAoC Interface Dependency Graph");
            sb.AppendLine("  %% Auto-generated by FIEX-015");
            sb.AppendLine();
            
            // Add styling classes
            sb.AppendLine("  classDef coreClass fill:#e1f5fe,stroke:#0277bd,stroke-width:2px");
            sb.AppendLine("  classDef combatClass fill:#e8f5e8,stroke:#388e3c,stroke-width:2px");
            sb.AppendLine("  classDef itemClass fill:#fff3e0,stroke:#f57c00,stroke-width:2px");
            sb.AppendLine("  classDef characterClass fill:#fce4ec,stroke:#c2185b,stroke-width:2px");
            sb.AppendLine();

            var relationships = new HashSet<string>();
            var interfaceStyles = new List<string>();

            foreach (var interfaceType in _allInterfaces)
            {
                var nodeName = CleanNodeName(interfaceType.Name);
                var category = GetInterfaceCategory(interfaceType);
                interfaceStyles.Add($"  class {nodeName} {category}");

                // Add inheritance relationships (solid lines)
                foreach (var baseInterface in interfaceType.GetInterfaces())
                {
                    if (_allInterfaces.Contains(baseInterface))
                    {
                        var baseName = CleanNodeName(baseInterface.Name);
                        relationships.Add($"  {nodeName} --> {baseName}");
                    }
                }
                
                // Add composition relationships (dashed lines)
                var dependencies = GetTypeDependencies(interfaceType);
                foreach (var dep in dependencies.Where(d => _allInterfaces.Contains(d)))
                {
                    var depName = CleanNodeName(dep.Name);
                    relationships.Add($"  {nodeName} -.-> {depName}");
                }
            }

            // Add all relationships
            foreach (var relationship in relationships.OrderBy(r => r))
            {
                sb.AppendLine(relationship);
            }

            sb.AppendLine();
            
            // Add styles
            foreach (var style in interfaceStyles.OrderBy(s => s))
            {
                sb.AppendLine(style);
            }

            return sb.ToString();
        }

        private string CreateAnalysisReport()
        {
            var sb = new StringBuilder();
            sb.AppendLine("# Interface Dependency Analysis Report");
            sb.AppendLine();
            sb.AppendLine($"**Generated**: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
            sb.AppendLine($"**Project**: OpenDAoC Core - Week 2 Interface Extraction");
            sb.AppendLine($"**Task**: FIEX-015 - Interface Dependency Graphs");
            sb.AppendLine();

            // Executive Summary
            sb.AppendLine("## Executive Summary");
            sb.AppendLine();
            
            var inheritanceCount = _allInterfaces.Sum(t => t.GetInterfaces().Count(i => _allInterfaces.Contains(i)));
            var compositionCount = _allInterfaces.Sum(t => GetTypeDependencies(t).Count(d => _allInterfaces.Contains(d)));
            var ispCompliant = _allInterfaces.Count(t => t.GetMembers().Length <= 5);
            var ispPercentage = _allInterfaces.Length > 0 ? (double)ispCompliant / _allInterfaces.Length * 100 : 0;
            
            sb.AppendLine($"- **Total Interfaces Analyzed**: {_allInterfaces.Length}");
            sb.AppendLine($"- **Inheritance Relationships**: {inheritanceCount}");
            sb.AppendLine($"- **Composition Dependencies**: {compositionCount}");
            sb.AppendLine($"- **ISP Compliance**: {ispCompliant}/{_allInterfaces.Length} ({ispPercentage:F1}%)");
            sb.AppendLine($"- **Architecture Health**: {GetArchitectureHealthStatus(ispPercentage)}");
            sb.AppendLine();

            // Interface Categories
            var categories = new[]
            {
                ("Core Game Objects", _allInterfaces.Where(IsCore).ToArray()),
                ("Combat System", _allInterfaces.Where(IsCombat).ToArray()),
                ("Character System", _allInterfaces.Where(IsCharacter).ToArray()),
                ("Item System", _allInterfaces.Where(IsItem).ToArray()),
                ("Utility Interfaces", _allInterfaces.Where(t => !IsCore(t) && !IsCombat(t) && !IsCharacter(t) && !IsItem(t)).ToArray())
            };

            sb.AppendLine("## Interface Categories");
            sb.AppendLine();

            foreach (var (categoryName, interfaces) in categories)
            {
                if (interfaces.Length > 0)
                {
                    sb.AppendLine($"### {categoryName} ({interfaces.Length} interfaces)");
                    sb.AppendLine();
                    
                    foreach (var iface in interfaces.OrderBy(t => t.Name))
                    {
                        var memberCount = iface.GetMembers().Length;
                        var depCount = GetTypeDependencies(iface).Count(d => _allInterfaces.Contains(d));
                        var ispStatus = memberCount <= 5 ? "✅" : "⚠️";
                        sb.AppendLine($"- **{iface.Name}** {ispStatus} - {memberCount} members, {depCount} dependencies");
                    }
                    sb.AppendLine();
                }
            }

            // Complexity Analysis
            var complexInterfaces = _allInterfaces
                .Select(t => new { 
                    Interface = t, 
                    Dependencies = GetTypeDependencies(t).Count(d => _allInterfaces.Contains(d)),
                    Members = t.GetMembers().Length
                })
                .Where(x => x.Dependencies > 2 || x.Members > 5)
                .OrderByDescending(x => x.Dependencies + x.Members)
                .ToArray();

            if (complexInterfaces.Length > 0)
            {
                sb.AppendLine("## Complexity Analysis");
                sb.AppendLine();
                sb.AppendLine("Interfaces requiring attention (high dependencies or member count):");
                sb.AppendLine();

                foreach (var item in complexInterfaces.Take(10))
                {
                    sb.AppendLine($"### {item.Interface.Name}");
                    sb.AppendLine($"- **Members**: {item.Members} (target: ≤5)");
                    sb.AppendLine($"- **Dependencies**: {item.Dependencies} (target: ≤2)");
                    
                    if (item.Members > 5)
                    {
                        sb.AppendLine("- **ISP Violation**: Consider splitting into smaller interfaces");
                    }
                    
                    if (item.Dependencies > 2)
                    {
                        sb.AppendLine("- **High Coupling**: Review dependencies for necessity");
                        var deps = GetTypeDependencies(item.Interface).Where(d => _allInterfaces.Contains(d));
                        foreach (var dep in deps.Take(3))
                        {
                            sb.AppendLine($"  - Depends on: {dep.Name}");
                        }
                        if (item.Dependencies > 3)
                        {
                            sb.AppendLine($"  - ... and {item.Dependencies - 3} more");
                        }
                    }
                    sb.AppendLine();
                }
            }

            // Architecture Quality Assessment
            sb.AppendLine("## Architecture Quality Assessment");
            sb.AppendLine();
            
            sb.AppendLine("### Interface Segregation Principle (ISP)");
            sb.AppendLine($"- **Compliant**: {ispCompliant}/{_allInterfaces.Length} interfaces");
            sb.AppendLine($"- **Percentage**: {ispPercentage:F1}%");
            sb.AppendLine($"- **Target**: >80%");
            sb.AppendLine($"- **Status**: {(ispPercentage >= 80 ? "✅ PASSING" : "⚠️ NEEDS IMPROVEMENT")}");
            sb.AppendLine();

            if (ispPercentage < 80)
            {
                var violations = _allInterfaces.Where(t => t.GetMembers().Length > 5).ToArray();
                sb.AppendLine("**ISP Violations:**");
                foreach (var violation in violations.Take(5))
                {
                    sb.AppendLine($"- {violation.Name}: {violation.GetMembers().Length} members");
                }
                if (violations.Length > 5)
                {
                    sb.AppendLine($"- ... and {violations.Length - 5} more");
                }
                sb.AppendLine();
            }

            // Recommendations
            sb.AppendLine("## Recommendations");
            sb.AppendLine();
            
            sb.AppendLine("### Immediate Actions (Week 2 Completion)");
            if (ispPercentage < 80)
            {
                sb.AppendLine("- **Priority 1**: Split large interfaces violating ISP");
            }
            sb.AppendLine("- **Priority 2**: Complete interface unit tests (FIEX-013)");
            sb.AppendLine("- **Priority 3**: Validate all interface segregation (FIEX-014)");
            sb.AppendLine();
            
            sb.AppendLine("### Week 3 Preparation");
            sb.AppendLine("- Setup clean architecture layers");
            sb.AppendLine("- Implement dependency rules enforcement");
            sb.AppendLine("- Create layer boundary tests");
            sb.AppendLine();

            sb.AppendLine("### Long-term Improvements");
            sb.AppendLine("- Add XML documentation to all interfaces");
            sb.AppendLine("- Regular dependency graph reviews");
            sb.AppendLine("- Automated ISP validation in CI/CD");
            sb.AppendLine("- Performance testing for hot path interfaces");

            return sb.ToString();
        }

        #region Helper Methods

        private List<Type> GetTypeDependencies(Type interfaceType)
        {
            var dependencies = new HashSet<Type>();

            // Get dependencies from method signatures
            foreach (var method in interfaceType.GetMethods())
            {
                AddTypeToSet(method.ReturnType, dependencies);
                foreach (var param in method.GetParameters())
                {
                    AddTypeToSet(param.ParameterType, dependencies);
                }
            }

            // Get dependencies from properties
            foreach (var property in interfaceType.GetProperties())
            {
                AddTypeToSet(property.PropertyType, dependencies);
            }

            return dependencies.Where(t => t != interfaceType).ToList();
        }

        private void AddTypeToSet(Type type, HashSet<Type> set)
        {
            // Add direct interface dependencies
            if (type.IsInterface && type.Assembly == _gameServerAssembly)
            {
                set.Add(type);
            }

            // Handle generic types
            if (type.IsGenericType)
            {
                foreach (var genericArg in type.GetGenericArguments())
                {
                    AddTypeToSet(genericArg, set);
                }
            }
        }

        private string CleanNodeName(string name)
        {
            // Remove 'I' prefix and make safe for Mermaid
            return name.StartsWith("I") ? name.Substring(1) : name;
        }

        private string GetInterfaceCategory(Type interfaceType)
        {
            if (IsCore(interfaceType)) return "coreClass";
            if (IsCombat(interfaceType)) return "combatClass";
            if (IsCharacter(interfaceType)) return "characterClass";
            if (IsItem(interfaceType)) return "itemClass";
            return "coreClass";
        }

        private bool IsCore(Type type) => 
            type.Name.Contains("GameObject") || type.Name.Contains("Identifiable") || 
            type.Name.Contains("Positionable") || type.Name.Contains("EventNotifier");

        private bool IsCombat(Type type) => 
            type.Name.Contains("Attack") || type.Name.Contains("Defend") || 
            type.Name.Contains("Damage") || type.Name.Contains("Combat");

        private bool IsCharacter(Type type) => 
            type.Name.Contains("Character") || type.Name.Contains("Player") || 
            type.Name.Contains("Living") || type.Name.Contains("Stats");

        private bool IsItem(Type type) => 
            type.Name.Contains("Item") || type.Name.Contains("Inventory") || 
            type.Name.Contains("Weapon") || type.Name.Contains("Armor") || 
            type.Name.Contains("Equipment");

        private string GetArchitectureHealthStatus(double ispPercentage)
        {
            if (ispPercentage >= 90) return "🟢 Excellent";
            if (ispPercentage >= 80) return "🟡 Good";
            if (ispPercentage >= 70) return "🟠 Fair";
            return "🔴 Needs Work";
        }

        #endregion
    }
} 